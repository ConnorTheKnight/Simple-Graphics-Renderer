# Premise
This program is an attempt to simulate a graphics renderer by implementing both a culling algorithm to determine which shapes out of a set of user provided shapes should be drawn and a drawing algorithm to determine which pixels are occupied by those shapes which should be drawn. The two algorithms are implemented both sequentially and concurrently for a variety of shapes in order to determine the performance increases involved with using multithreading in this approximation of a real world application.
# Overview of the code for the sequential algorithms
## Reading in data
The program reads in data line by line beginning with the information required to initialize the size of each of the vectors which will be storing the data of each shape being the number of rows in the grid, the number of columns in the grid, and finally the number of shapes that the user wants to render. Then the program will sequentially read in the data for each shape line by line beginning with the specific information for the shape (side length for squares, radius for circles, height and width of rectangles, etc) then by reading the X and Y coordinates for each shape. It is important to note that the information for the shape is read in and stored as floating point values and as such need not be aligned to the grid.
## Culling Algorithm
### Defining terms:
 The premise of the culling algorithm is that if a shape is completely covered by another shape that the program will draw at some point then there is no need to draw that shape since its redundant work.
 In order to formalize this for the purposes of this explanation each shape will be viewed as some mathematical set of points which satisfy the mathematical formula which expresses that shape, for example, a circle with a radius of R and a center at (X, Y) is defined as the set of all points which satisfies the condition that X minus the x coordinate of the point squared when added to Y minus the y coordinate of the point squared is less than or equal to R squared.
Under this definition of shapes, a shape is “completely covered” when it is a subset of some other shape in the set of shapes that the program will draw.
### Actual implementation:
The sequential culling algorithm takes a very straight forward approach with an important optimization to prevent it from performing redundant calculations. The basic premise of the algorithm is a brute force approach in which the program loops through each shape and compares it to every other shape determining if the first shape is completely covered by the second shape. If the function returns true, the first shape is marked as culled and will be skipped by the drawing algorithm.
Before comparing one shape to another the program will first check if the second shape has already been marked as culled and if it has the program will skip comparing against it. The reasoning behind why this works is that if a shape has been marked as culled then it must be a subset of some other shape, therefore, any shape which is completely covered by a culled shape must also be completely covered by at least one other shape through the transitivity property of subsets. Because this is the case there is no need to compare shapes to those that have been marked as culled as if the shape which is being compared would have been completely covered by the culled shape then there will be at least one other shape in the set of shapes that the program will draw that would also cover that shape and thus the first comparison is redundant.
In the edge case that two shapes are the same set then it is possible for them to be subsets of each other, similarly if a shape is compared with itself then it will also be a subset of itself. The former case is already solved by the optimization which prevents shapes from being compared against shapes already marked as culled will prevent two shapes of the same size from being compared will eachother since one shape will first be culled by the other and then the other shape will never be compared against the first. It is important to note that this only solves this case for the sequential algorithm where one shape will always be evaluated before the other and they cannot be compared at the same time as can be the case in the concurrent algorithm later on. The latter case can be solved by one additional check that the index of the outer loop is not the same as the index of the inner loop and thus no shape can be compared with itself.
## Drawing algorithm
Similar to the culling algorithm, the drawing algorithm is based on a brute force approach with a few key optimizations to make it significantly less costly in terms of performance.
The main premise of the drawing algorithm is to loop through each shape getting drawn and evaluate each grid unit which could be in the shape and see if it satisfies the formula which serves as the requirement for being in the set that represents that shape.
The first key optimization is that every shape that was marked as culled by the culling algorithm is skipped. The reasoning behind this is because as discussed earlier a shape which Is marked as culled is a subset of some other shape, therefore any grid unit which would be included in the set of a culled shape will also be included in the set of at least one unculled shape and thus evaluating for a culled shape is redundant.
The second key optimization is that instead of evaluating the entire grid for each shape, the program will find the minimum rectangle of grid units which it can guarantee contains each grid unit that will be present in that shape and only evaluate the grid units present in that rectangle rather than evaluating the entire grid. It does this first by finding the top left corner’s X coordinate, the top left corner’s y coordinate, the height, and the width of the actual rectangle with an approximately minimum size that will completely cover that shape using a mathematical formula which varies from shape to shape. Then the program will find the floor of the x and y coordinates of the top left corner of that square, by casting their floating point values to integers, to find the coordinates of a grid unit that will serve as the top left corner of the grid aligned rectangle. After this the program will find an appropriate height and width for the grid aligned rectangle by adding two to the floating point value of the height and width of the un aligned rectangle and then casting each one to an integer value. The reasoning for this is that each side length on the aligned rectangle must be inaccurate by some fractional value less than 1 in each direction with the upper bound for this imprecision being equal to 2, thus by taking the floor of 2 plus each side length we find a side length which when added to the top left corner calculated earlier is guaranteed to be larger than the actual rectangle’s side length added to its top left corner.
## Output
The current implementation of the output is to loop through each grid unit and print a text representation of whether that grid unit is filled or not filled with “[_]” representing not filled and “[X]” representing filled with a new line character present at the end of each row of grid units to create a graphical representation of the state of the grid.
# Making the sequential algorithm into a concurrent algorithm
## Parallelization
 The program makes use of multithreading by evenly distributing the calculations made in the for loops of the culling and drawing algorithm among multiple threads. This works because the calculations made in the culling and drawing algorithms are not affected by the order they are performed in with a few exceptions meaning that race conditions are for the most part avoided.
There are a few notable exceptions however in the culling algorithm in which the program is affected by the order that each part is performed in. The first of these exceptions is that if multiple threads are determining if the same shape is to be culled they will each begin each calculation by checking if the shape they are evaluating has already been culled before continuing on to make the same optimizations present in the sequential algorithm. The synchronization protocol for this case is that the first thread to determine that the shape should be culled is considered correct and all other threads stop calculating, this works because shapes can only ever be culled and never unculled thus when the shape is determined to be culled by one thread it leads to the same result as any other thread determining it should be culled, with a shape only not being culled if all threads evaluate that it should not be culled. The second exception is that if two shapes have the same position and dimensions then two threads may evaluate both at the same time and decide that they both are covering each other incorrectly when one should cover the other, in order to prevent this an additional check must be made to determine if two shapes have the same dimensions and if so the shape with the greater index should be culled and since indexes do not vary between threads this will ensure that the thread managing one shape decides it should be culled while the other should not.
## Thread Distribution
In order to ensure a fair distribution of work over an arbitrary amount of threads, the program will attempt to evenly distribute the work of each for loop used in the sequential algorithm between the available threads. It does this by first checking if there are enough threads to handle the outermost for loop, if there are it will then divide up the remaining threads between each of those threads to evenly distribute the calculations of the next nested for loop. This continues until either there are not enough threads available to handle the calculations at each index, the overhead of creating threads is greater than the performance cost of performing the calculations sequentially, or there are no more nested for loops for the program to use threads to solve concurrently. In the first case, when the program does not have enough threads to handle the calculations at each index, it will instead assign each thread an approximately equal range of indices to handle the calculations for and those threads will solve each index identically to the sequential algorithm since there are no more threads to distribute.
In the case that the number of threads remaining after assigning each thread to an index does not divide evenly between the number of indices or in the case that there are not enough threads for each index and the number of indices does not divide evenly between the number of remaining threads, the program will first get a lower bound for the number of threads or indices by performing integer division and will then get the remainder using modulus. The program will then distribute the lower bound number of threads or indices but add one additional thread or index for the first n threads where n is the remainder calculated earlier. This process ensures that when evenly distributing resources the program will get as close to evenly distributing indivisible quantities as possible while not leaving any resource undistributed.
## Shared Resources
Among the arrays which are shared between each thread, the arrays which store the information about each shape are never written to and as such threads can share access without having to worry about mutual exclusion. The remaining arrays which are shared and are written to during the concurrent algorithms use atomic read and atomic write operations to ensure that there are no undefined behaviors when the resource is being accessed.
Experimental Results

### Compilation and Execution Instruction

## Compiling a Single C++ File
To compile a **single C++ file**, use:
```sh
g++ -o output_filename source_file.cpp
```

## Input Format
- INT (Vertical Extent/Grid Limit)
- INT (Horizontal Extent/Grid Limit)
- INT (Number of Shapes)
- X COORD for shape 1
- Y COORD for shape 1
- X COORD for shape 2
- Y COORD for shape 2
- ...

Example:
```sh
10
10
1
3
4
```
